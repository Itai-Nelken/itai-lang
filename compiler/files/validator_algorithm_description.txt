program:
    For every MODULE:
        For every TYPE:
            * id types -> the struct type they refer to.
            * fn types -> validate param types + return type
            * pointer types -> validate pointee
            * struct types -> TODO
        For every VARIABLE DECLARATION (MODULE SCOPE):
            * validate initializer (if it exists.)
            * infer type (if necessary.)
            * make sure there is a type (that is not void.)
            * Make sure not assigned to itself.
        For every SCOPE (starting with the moduleScope and walking the scope tree):
            For every OBJECT:
                * variables
                    - do nothing.
                * functions
                    - <validate function. see steps below>

<enter scope>:
1. Set current scope to the scope we are entering.
2. Validate scope. See above (under module.)

<validate function>:
1. "Declare" all parameters as local variables (add to scope.)
2. Validate body. see steps below.

<validate body> (actualy recursive validate statement):
1. Enter scope
2. For each node, do (depending on type):
    VAR_DECL: validate variable decl (see above under module), add to scope ("declare".)
    EXPR: <validate expr. see below>
    (others are trivial/require nothing complicated to do with scopes etc. that I can think of right now.)
3. Leave scope


<validate expr>:
1. For each node, do (depending on type):
    IDENTIFIER: replace with ASTObj the identifier refers to.
    ASSIGN: make sure assignment target is valid (variable - including property access, dereference (I think).)
    CALL: check that callee is callable, validate argument expressions + correct amount of them.
2. Also set the data type for each node.


==== OTHER NOTES ====
* Since order of functions, module variables, struct fields doesn't matter, we don't care about the order they were declared in (obviously.)
* Order DOES matter for everything inside a function (local variables, statements).
* Validation process builds an enitrely new AST - including using a new program.
    - This allows using the checked scopes to check if a variable has been declared for example.
    - Makes sure we can't accidentally forget an unvalidated node (or any other AST object).
    - Means we can free the parsed program at the end of validation (i.e. reuse of anything from the parsed AST is BAD.)
* All validation functions should require that their parsed input is NOT NULL.
    - This should be a checked runtime error (C.R.E.)
